var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SmoothTree]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#Distributions.logpdf-Tuple{BetaSplitTree, Any, Any}","page":"API","title":"Distributions.logpdf","text":"logpdf(m::BetaSplitTree, γ, δ)\n\nGet the log-probability of observing clade γ with split δ under the Beta-splitting model m.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree._inner_serial!-NTuple{5, Any}","page":"API","title":"SmoothTree._inner_serial!","text":"_inner_serial!(...)\n\nThis is in the ABC simulation algorithm within the EP site update (see Bartelmé & Chopin), implemented in a serial fashion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree._inner_threaded!-NTuple{5, Any}","page":"API","title":"SmoothTree._inner_threaded!","text":"_inner_threaded!(...)\n\nSee _inner_serial!, but in a multi-threaded implementation using a user-defined batch size for simulation batches executed in parallel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree._momentmatching-NTuple{4, Any}","page":"API","title":"SmoothTree._momentmatching","text":"_momentmatching(...)\n\nCompute the new global approximation by approximating the tilted distribution within the exponential family using some form of moment matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree._tuneh!-NTuple{4, Any}","page":"API","title":"SmoothTree._tuneh!","text":"_tuneh!(...)\n\nTune the h parameter and re-evaluate accepted simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.ep!","page":"API","title":"SmoothTree.ep!","text":"ep!(alg, n; kwargs...)\n\nDo n serial EP passes.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoothTree.ep_iteration-Tuple{Any, Any}","page":"API","title":"SmoothTree.ep_iteration","text":"ep_iteration(alg, i)\n\nDo a single EP site update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.ep_serial!-Tuple{Any}","page":"API","title":"SmoothTree.ep_serial!","text":"ep_serial!(alg; rnd=true)\n\nSerial EP pass. When rnd=true the pass goes over the data in a random order. \n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.logpartition-Tuple{MSCModel}","page":"API","title":"SmoothTree.logpartition","text":"logpartition(model::MSCModel)\n\nCompute the logpartition function of the MSCModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.logpartition-Tuple{NatMBM}","page":"API","title":"SmoothTree.logpartition","text":"logpartition(x::AbstractMBM)\n\nCompute the log-partition function for x.\n\nThe log-partition function of a categorical distribution on k categories with moment parameter θ = (θ1, θ2, …, θ{k-1}) is -log(1-∑i θi) = -log θk. The MBM defines a categorical distribution on tree topologies. We have defined an order on trees (in particular we have a well-defined last tree, see reftree). So it appears we can easily compute -log θk. \n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.matchmoments-Union{Tuple{T}, Tuple{Any, MSCModel{T}, Any}} where T","page":"API","title":"SmoothTree.matchmoments","text":"updated_model(trees, cavity, α)\n\nMethod to update the full approximation by moment matching.  This matches the moments of the MBM distribution to the Dirichlet-MBM posterior with prior α for the accepted trees, and updates the Gaussian distributions for the branch parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.pep!","page":"API","title":"SmoothTree.pep!","text":"pep!(alg, n)\n\nDo n (embarrassingly) parallel EP passes.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoothTree.prune-Union{Tuple{M}, Tuple{V}, Tuple{T}, Tuple{M, Any}} where {T, V, M<:SmoothTree.AbstractMBM{T, V}}","page":"API","title":"SmoothTree.prune","text":"prune\n\nPrune a sparsely represented MBM object by setting all represented splits with split probabilities indistinguishable from the probability of an unrepresented split to the latter (thereby removing the split from the set of explicitly represented splits).\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.prune-Union{Tuple{V}, Tuple{T}, Tuple{SmoothTree.SparseSplits{T, V}, Any}} where {T, V}","page":"API","title":"SmoothTree.prune","text":"prune(x::SparseSplits, atol=1e-9)\n\nPrune out splits which are barely supported (have η ≈ η0, with absolute tolerance atol)\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.randsplit-Tuple{BetaSplitTree, Any}","page":"API","title":"SmoothTree.randsplit","text":"randsplit(m::BetaSplitTree, γ)\n\nGenerate a random split of clade γ for the Beta splitting model m\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.randsplitofsize-Union{Tuple{T}, Tuple{T, Any}} where T","page":"API","title":"SmoothTree.randsplitofsize","text":"randsplitofsize(γ, k)\n\nPick a split uniformly from the set of splits of size k in clade γ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.randtree-Tuple{SmoothTree.MSCSampler}","page":"API","title":"SmoothTree.randtree","text":"randtree(model::MSCSampler)\n\nSimulate a species tree from an MSCModel (in the EP-ABC algorithm this is used to simulate from the cavity)\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.traceback-Tuple{Any}","page":"API","title":"SmoothTree.traceback","text":"traceback\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.BetaSplitTree","page":"API","title":"SmoothTree.BetaSplitTree","text":"BetaSplitTree(β, n)\n\nStores the relevant pmf's for a Beta-splitting Markov branching model on cladograms.\n\nβ ∈ (-2, Inf]: the shape parameter (β → -2.0 gives comb tree with probability one, β=-1.5 gives PDA, β=-1 gives AB, β=0 gives Yule, β=Inf gives random partition tree)\np: Beta-splitting pmfs for clades of size 3 to n\nq: Beta-splitting probabilities per split, i.e. probability of a split of size i of a clade of size k is p[k-2][i]/binomial(k,i) when 2i ≠ k.  \nn: root clade size\n\nReferences\n\nAldous, David. \"Probability distributions on cladograms.\" Random discrete structures. Springer, New York, NY, 1996. 1-18.\nJones, Graham R. \"Tree models for macroevolution and phylogenetic analysis.\" Systematic biology 60.6 (2011): 735-746.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.BiMap","page":"API","title":"SmoothTree.BiMap","text":"BiMap{T,V}\n\nBijective map for distinct types, so that getindex dispatches on type.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.BranchModel","page":"API","title":"SmoothTree.BranchModel","text":"BranchModel{T,V}\n\nThe BranchModel stores for each clade, potentially, a natural parameter vector, and has a fallback η0 representing the natural parameter vector for unrepresented clades. For the global model,  the latter will be the prior. For an individual site η0 will be zero.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.CCD","page":"API","title":"SmoothTree.CCD","text":"CCD(trees::Vector; [lmap=taxon_map])\nCCD(trees::AbstractDict; [lmap=taxon_map])\n\nA conditional clade distribution (CCD) object. \n\nInput data can be either a vector of trees or a countmap of trees (see StatsBase.countmap).\n\nExamples\n\njulia> ccd = CCD([nw\"((A,B),C);\", nw\"((B,C),A);\", nw\"((A,B),C);\"])\nCCD{UInt16}(n=3, Γ=7)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.EPABC","page":"API","title":"SmoothTree.EPABC","text":"EPABC(data, prior; kwargs...)\n\nExpectation-propagation approximate Bayesian computation (EP-ABC, or likelihood free EP) algorithm struct. See ep! and pep!.\n\nReferences\n\nBarthelmé, Simon, and Nicolas Chopin.  \"Expectation propagation for likelihood-free inference.\"  Journal of the American Statistical Association  109.505 (2014): 315-333.\nBarthelmé, Simon, Nicolas Chopin, and Vincent Cottet.  \"Divide and conquer in ABC: Expectation-propagation algorithms  for likelihood-free inference.\"  Handbook of Approximate Bayesian Computation.  Chapman and Hall/CRC, 2018. 415-434.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.MSC","page":"API","title":"SmoothTree.MSC","text":"MSC(species_tree, initialization::Dict)\n\nMulti-species coalescent distribution over gene trees for a given species tree with branch lengths in coalescent units. \n\nThe initialization is a dictionary recording for each leaf node of the species tree a vector of genes, which should be clade labels (i.e. powers of 2) (see taxonmap and the example below).\n\nExample\n\njulia> tree = nw\"((F,(G,H):1):1,((B,((A,C):1,(D,E):1):1):1,O):1);\";\n       m = taxonmap(tree);\n       init = Dict(id(n)=>[m[name(n)]] for n in getleaves(tree))\nDict{UInt16, Vector{UInt16}} with 9 entries:\n  0x0005 => [0x0002]\n  0x000d => [0x0020]\n  0x0006 => [0x0004]\n  0x000f => [0x0040]\n  0x0010 => [0x0080]\n  0x0009 => [0x0008]\n  0x000c => [0x0010]\n  0x0011 => [0x0100]\n  0x0003 => [0x0001]\n\njulia> M = SmoothTree.MSC(tree, init);\n       randtree(M, m)\n((F,(D,E)),((G,H),((B,(A,C)),O)));\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.MSCModel","page":"API","title":"SmoothTree.MSCModel","text":"MSCModel\n\nAn object for conducting variational species tree inference under the multispecies coalescent model. Note that:\n\nWe approximate the tree topology posterior by a MBM\nWe approximate the branch parameter posterior by independent Gaussians, one for each clade, i.e. representing the parameter for the branch leading to that clade as a crown group.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.MomBranchModel","page":"API","title":"SmoothTree.MomBranchModel","text":"MomBranchModel\n\nBranchModel in moment parameter space, not really used, more for convenience (interpretability).\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.MomMBM","page":"API","title":"SmoothTree.MomMBM","text":"MomMBM\n\nA MBM model in moment parameter space.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.MomMBM-Tuple{CCD, Vararg{Any}}","page":"API","title":"SmoothTree.MomMBM","text":"MomMBM(x::CCD, β::BetaSplitTree, α::Real)\nNatMBM(...)\n\nGet the posterior mean Markov branching model assuming a Dirichlet prior distribution with parameter proportional to a Beta-splitting model and weight α (i.e. the Dirichlet parameter vector for each Categorical split distribution sums to α, so that α serves as a total pseudocount) and observed splits recorded in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoothTree.NatMBM","page":"API","title":"SmoothTree.NatMBM","text":"NatMBM\n\nA MBM model in natural parameter space.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.SparseSplits","page":"API","title":"SmoothTree.SparseSplits","text":"SparseSplits\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoothTree.SparseSplits-Union{Tuple{T}, Tuple{Any, Dict{T, Int64}, Any, Any}} where T","page":"API","title":"SmoothTree.SparseSplits","text":"Get a natural parameter SparseSplits object from split counts d, assuming the Beta-splitting Dirichlet prior with pseudo-count α and shape parameter β. \n\n\n\n\n\n","category":"method"},{"location":"","page":"Index","title":"Index","text":"SmoothTree","category":"page"},{"location":"","page":"Index","title":"Index","text":"Documentation/examples coming soon","category":"page"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"This page was generated using Literate.jl.","category":"page"}]
}
